===================
   TODO: ranvier
===================

* Remove dependencies on hume::

    13 matches for "response\." in buffer: resource.py
        432:        response.setContentType('text/plain')
        435:            response.write('\n')
        580:                response.error(response.code.NotFound)
         27:        response.redirect(self._target)
         50:        response.error(response.code.Forbidden)
        168:                    response.error(response.code.Forbidden)


  * Move some of the resources back to hume, to avoid dependencies


* Add to my template headers the rendering of the resource-id.

* Implement enum() on all the resource classes everywhere.

* Implement all the remaining features described in the docs

* We need to implement a method on the UrlMapper that can load it from it clean
  rendered description.

* Make sure for all resource classes that we initialize the parent resource
  class for its resid.

* Add tests for everything.

* For folder with default: we should declare the directory as being served as
  well, but how do we deal with the conflict in names?  It consists in two
  differents paths leading to the same resource.  Should we perhaps check that
  resources given during a single visit be unique?  What does it all mean?

* The resources package should be split away from the rest  DO IT!!!
* Write tests

  * Instances that can be referenced should take a '//key' code string so that
    we are able to map resources back into URLs.  Do this by using the **kwds
    varargs and having every node cherrypick what it needs when moving back
    towards the root of the tree.

* Update all the resources everywhere for their enum method.

* Add a call so that the mapper implements the root handle method:

  - Create a context object
  - Catch the internal redirects and apply them automatically


* Add the following methods:

  - declare_var() becomes declare_compvar()
  - declare_param( ..., optional=True ) -> adds a query arg

    Only parameters can be optional.  Variables are required.

    Find a way to map the position parameters to the URL, in order.

  - Add a optional parameter 'extra' which can be used to indicate, for
    informational purposes only, what extra data is involved/considered during
    the traversal for a particular leaf resource.  This can be used to display
    the privileges that are involved in accessing a single resource.


* Add a UrlMapper.handle() method that takes care of the forward mapping.
  This way, the mapper becomes the central point-of-control after the tree is
  built.  handle method should create the context and protect the handle call
  for internal redirects.



* Mention that this could be used to generate the Google sitemap



* The documentation could be parsed like a template to fill in links to the demo
  using a mapper object.  We will have to write a small python program that
  creates the mapper and that does that..


* We will write our own simple test by getting the list of resources and
  attempting to fetch all of them.  We will need introspection on the list of
  variables of each resource, so that we can generate random data.



* Provide a simple template replacement routine that replaces::

      <a href="@@Profile(username=username, ...)">Search</a>

  This should be configured to use an appropriate mapper.

* In the docs, mention that the list of URLs can be used by a new developer to
  quickly get acquainted with the layout of a new project.  This could also be
  used to generate a site map.

* Hide rest better in resources, rename it::

   Resource.resid -> Resource._Ranvier_resid

* Write a test program using an Apache rewrite rule on a CGI script, to give the
  impression that we're running a web application.  Rewrite to::

     /ranvier/demo/handle.cgi?url=/users/blais/home&arg1=val1&arg2=val2


* Plop in a global ``url()`` function for doing the inverse mappings::

    from app import url
    def url( *args, **kwds ):
        # Use the global URL mapper instance.
        return mapper.url(*args, **kwds)


* We need to figure out some kind of solution for the forms which are defined at
  module initialization time, to be able to generate the actual URLs later when
  the mapper has been created.

  (Atocha)
  - Implement support for a callable to be used for the action= arguments in
    Atocha.


  - Add a global function that returns a closure to do this::

     def delayed_url( *args, **kwds ):
         # Capture the parameters and return a callable.
         def durl():
             url(*args, **kwds)
         return durl

         
* Consider adding positional arguments to the call to url().  For this you will
  have to somehow save the order of the parameters somewhere.


* Add a function to initialize ::

    __builtin__.__dict__['url'] = mapper.url()

  Call this function from the carpool app framework.


* Remove htmlout from all Ranvier code (FolderWithMenu)


* Send Ranvier information to twill list when the URL mapper for testing is
  complete.

* Check out if we could not use WSGI to implement our response proxy.


* Run an import-check before submitting anywhere.

* See if I cannot remove the redundant rootloc stored in the context and
  locator.  This is already stored in the URL mapper.



Query Parameters
================

* Think about integrating the parameters with the query arguments at some point,
  so that we can generate URLs like this (maybe this could be done automatically
  by passing in extra arguments instead of raising an error):

     /a/bli/blou?myextra=42


* The enumerator visitor could be augmented with a method to accept declaration
  of possible query arguments, some being mandatory (this sounds like a cool
  idea).

  Also, a special function could be provided to do these declarations given an
  Atocha form, thus providing us with the complete interface to a speciific
  resource.  The pretty renderer could take advantage of that by rendering a
  nice table with those, and the fields' titles could even be declared as well,
  so that we can render a good interface of a resource.



Back into Hume
==============

* Add these back into hume, to be able to serve the URL mapper contents::

    #-------------------------------------------------------------------------------
    #
    class EnumResource( Resource ):
        """
        Enumerate all the resources available from a resource tree.
        """
        def __init__( self, mapper, **kwds ):
            Resource.__init__(self, **kwds)
            self.mapper = mapper

        def handle( self, ctxt ):
            response.setContentType('text/plain')
            for line in self.mapper.render():
                response.write(line)
                response.write('\n')


    class PrettyEnumResource(Resource):
        """
        Output a rather nice page that describes all the pages that are being served
        from the given mapper.
        """
        def __init__( self, mapper, **kwds ):
            Resource.__init__(self, **kwds)
            self.mapper = mapper

        def handle( self, ctxt ):
            response.setContentType('text/html')
            response.write(self.mapper.pretty_render())
