===================
   TODO: ranvier
===================

(main features)

* Put ranvier mappings in a Mappings class rather than to use a tuple (it's big
  enough now)

Conversion:

             imports-and-rename  handle  enumv

hume         x                   x       x
walus        x                   x
carpool      x                   x


X imports-and-rename: 
X * rename imports to ranvier, 
X * Replace all Resource to LeafResource where applicable
X 
X handle:
X * Revise the names of all the handle* methods
X * Remove all direct calls to handle()

X * Review folders, the first arg changed and is now optional (_default).

X * Check the handle methods of all the classes derived from Folder
X * Rename all calls to handle_this() to handle() and make sure they are based on DelegaterResource

enumv:
X * Implement all enumv methods, look for all calls to locator.current(), locator.next()

X * The photo link does not show up in the carpool application







* Add positional arguments to the call to url().  For this you will
  have to somehow save the order of the parameters somewhere.  Then we need
  tests for calls to url(), with all possible combinations.



* We need to implement a method on the UrlMapper that can load itself from a
  clean rendered description, the same as served by the enum resources, to work
  from the tests.



* Add a call so that the mapper implements the root handle method:

  - Create a context object
  - Catch the internal redirects and apply them automatically

* Add tests for everything.

  * We will write our own simple test by getting the list of resources and
    attempting to fetch all of them.  We will need introspection on the list of
    variables of each resource, so that we can generate random data.


* Add the following methods:

  - declare_param( ..., optional=True ) -> adds a query arg

      ##     def declare_queryargs( self, varname, default=None, optional=False ):
      ##         """
      ##         Declare query arguments for this resource as a leaf.  Query arguments
      ##         can be optional, and can have default values only if they're not
      ##         optional.
      ##         """
      ##         assert not (optional and default)
      ## ## FIXME todo


    Only parameters can be optional.  Variables are required.

    Find a way to map the position parameters to the URL, in order.

  - Add a optional parameter 'extra' which can be used to indicate, for
    informational purposes only, what extra data is involved/considered during
    the traversal for a particular leaf resource.  This can be used to display
    the privileges that are involved in accessing a single resource.

* Add a UrlMapper.handle() method that takes care of the forward mapping.
  This way, the mapper becomes the central point-of-control after the tree is
  built.  handle method should create the context and protect the handle call
  for internal redirects.

* Implement and test internal redirects.

  Investigate this: when you just return a Location: header without a status,
  Apache goes into an infinite loop.  What is this implementation of internal
  redirect?  Look for internal redirection on Wikipedia.

* Provide a simple template replacement routine that replaces::

      <a href="@@Profile(username=username, ...)">Search</a>

  This should be configured to use an appropriate mapper.



* Plop in a global ``url()`` function for doing the inverse mappings::

    from app import url
    def url( *args, **kwds ):
        # Use the global URL mapper instance.
        return mapper.url(*args, **kwds)

* Add a function to initialize ::

    __builtin__.__dict__['url'] = mapper.url()

  Call this function from the carpool app framework.


(port all code)
* Move some resources back into hume

* Implement enum() on all the resource classes everywhere.

* Make sure for all resource classes that we initialize the parent resource
  class for its resid.


(atocha forms)

* We need to figure out some kind of solution for the forms which are defined at
  module initialization time, to be able to generate the actual URLs later when
  the mapper has been created.

  (Atocha)
  - Implement support for a callable to be used for the action= arguments in
    Atocha.

  - Add a global function that returns a closure to do this::

     def delayed_url( *args, **kwds ):
         # Capture the parameters and return a callable.
         def durl():
             url(*args, **kwds)
         return durl




(cleanup)
* See if I cannot remove the redundant rootloc stored in the context and
  locator.  This is already stored in the URL mapper.

* Implement all the remaining features described in the docs


(problems)
* What if I want to refer to a page along the path that is not a leaf?  How do
  we do that?  Like a parent directory

* For folder with default: we should declare the directory as being served as
  well, but how do we deal with the conflict in names?  It consists in two
  differents paths leading to the same resource.  Should we perhaps check that
  resources given during a single visit be unique?  What does it all mean?



(promotion)
* Send Ranvier information to twill list when the URL mapper for testing is
  complete.

(docs)
* In the docs, mention that the list of URLs can be used by a new developer to
  quickly get acquainted with the layout of a new project.  This could also be
  used to generate a site map.

* Mention that this could be used to generate the Google sitemap







Future
======

* branch_var should accept a tuple of variable names, and the same should go for
  declare_serve(), so that we can express consuming more than a single path
  component:

     /doc/<year>/<month>/<date>
     /doc/<year>/<month>/<date>/view

Interfaces
----------

* Check out if WSGI dictates some kind of standard interface for implementing a
  response proxy.


Query Parameters
----------------

* Think about integrating the parameters with the query arguments at some point,
  so that we can generate URLs like this (maybe this could be done automatically
  by passing in extra arguments instead of raising an error):

     /a/bli/blou?myextra=42

* The enumerator visitor could be augmented with a method to accept declaration
  of possible query arguments, some being mandatory (this sounds like a cool
  idea).

  Also, a special function could be provided to do these declarations given an
  Atocha form, thus providing us with the complete interface to a speciific
  resource.  The pretty renderer could take advantage of that by rendering a
  nice table with those, and the fields' titles could even be declared as well,
  so that we can render a good interface of a resource.
