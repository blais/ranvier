===================
   TODO: ranvier
===================

(main features)

* Replace all Resource to LeafResource where applicable

* Move some of the resources back to hume, to avoid dependencies

* Remove dependencies on hume::

    13 matches for "response\." in buffer: resource.py
        432:        response.setContentType('text/plain')
        435:            response.write('\n')
        580:                response.error(response.code.NotFound)
         27:        response.redirect(self._target)
         50:        response.error(response.code.Forbidden)
        168:                    response.error(response.code.Forbidden)



* Add positional arguments to the call to url().  For this you will
  have to somehow save the order of the parameters somewhere.


* We need to implement a method on the UrlMapper that can load it from it clean
  rendered description.

* Add a call so that the mapper implements the root handle method:

  - Create a context object
  - Catch the internal redirects and apply them automatically

* Add tests for everything.

  * We will write our own simple test by getting the list of resources and
    attempting to fetch all of them.  We will need introspection on the list of
    variables of each resource, so that we can generate random data.


* Add the following methods:

  - declare_param( ..., optional=True ) -> adds a query arg

    Only parameters can be optional.  Variables are required.

    Find a way to map the position parameters to the URL, in order.

  - Add a optional parameter 'extra' which can be used to indicate, for
    informational purposes only, what extra data is involved/considered during
    the traversal for a particular leaf resource.  This can be used to display
    the privileges that are involved in accessing a single resource.

* Add a UrlMapper.handle() method that takes care of the forward mapping.
  This way, the mapper becomes the central point-of-control after the tree is
  built.  handle method should create the context and protect the handle call
  for internal redirects.

* Implement and test internal redirects.

  Investigate this: when you just return a Location: header without a status,
  Apache goes into an infinite loop.  What is this implementation of internal
  redirect?  Look for internal redirection on Wikipedia.

* Provide a simple template replacement routine that replaces::

      <a href="@@Profile(username=username, ...)">Search</a>

  This should be configured to use an appropriate mapper.



* Plop in a global ``url()`` function for doing the inverse mappings::

    from app import url
    def url( *args, **kwds ):
        # Use the global URL mapper instance.
        return mapper.url(*args, **kwds)

* Add a function to initialize ::

    __builtin__.__dict__['url'] = mapper.url()

  Call this function from the carpool app framework.


(port all code)
* Move some resources back into hume

* Implement enum() on all the resource classes everywhere.

* Make sure for all resource classes that we initialize the parent resource
  class for its resid.


(atocha forms)

* We need to figure out some kind of solution for the forms which are defined at
  module initialization time, to be able to generate the actual URLs later when
  the mapper has been created.

  (Atocha)
  - Implement support for a callable to be used for the action= arguments in
    Atocha.

  - Add a global function that returns a closure to do this::

     def delayed_url( *args, **kwds ):
         # Capture the parameters and return a callable.
         def durl():
             url(*args, **kwds)
         return durl


(misc)
* Check out if WSGI dictates some kind of standard interface for implementing a
  response proxy.


(cleanup)
* Run an import-check before submitting anywhere.

* See if I cannot remove the redundant rootloc stored in the context and
  locator.  This is already stored in the URL mapper.

* Implement all the remaining features described in the docs


(problems)
* What if I want to refer to a page along the path that is not a leaf?  How do
  we do that?  Like a parent directory

* For folder with default: we should declare the directory as being served as
  well, but how do we deal with the conflict in names?  It consists in two
  differents paths leading to the same resource.  Should we perhaps check that
  resources given during a single visit be unique?  What does it all mean?



(promotion)
* Send Ranvier information to twill list when the URL mapper for testing is
  complete.


(docs)
* In the docs, mention that the list of URLs can be used by a new developer to
  quickly get acquainted with the layout of a new project.  This could also be
  used to generate a site map.

* Mention that this could be used to generate the Google sitemap




Query Parameters
================

* Think about integrating the parameters with the query arguments at some point,
  so that we can generate URLs like this (maybe this could be done automatically
  by passing in extra arguments instead of raising an error):

     /a/bli/blou?myextra=42


* The enumerator visitor could be augmented with a method to accept declaration
  of possible query arguments, some being mandatory (this sounds like a cool
  idea).

  Also, a special function could be provided to do these declarations given an
  Atocha form, thus providing us with the complete interface to a speciific
  resource.  The pretty renderer could take advantage of that by rendering a
  nice table with those, and the fields' titles could even be declared as well,
  so that we can render a good interface of a resource.



Back into Hume
==============

* Add these back into hume, to be able to serve the URL mapper contents::

    #-------------------------------------------------------------------------------
    #
    class EnumResource( Resource ):
        """
        Enumerate all the resources available from a resource tree.
        """
        def __init__( self, mapper, **kwds ):
            Resource.__init__(self, **kwds)
            self.mapper = mapper

        def handle( self, ctxt ):
            response.setContentType('text/plain')
            for line in self.mapper.render():
                response.write(line)
                response.write('\n')


    class PrettyEnumResource(Resource):
        """
        Output a rather nice page that describes all the pages that are being served
        from the given mapper.
        """
        def __init__( self, mapper, **kwds ):
            Resource.__init__(self, **kwds)
            self.mapper = mapper

        def handle( self, ctxt ):
            response.setContentType('text/html')
            response.write(self.mapper.pretty_render())
