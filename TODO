===================
   TODO: ranvier
===================

(code)

* ranvier: Add formatting to components upon declaration and remove all %08d
  strings everywhere

* Implement forward matching without going via the resource tree, and return a
  dict of the matched values.  Do this with a regexp, you give it a URL and it
  attempts to match it and return the components.  Should be easy

  The test can use this in order to check for specified resulting URLs with
  values.


* Move namexform somewhere else than the mapper, it should probably be global,
  add setting the resid() to ctxt.


* Implement Coverage Analysis, two separate statistics can be collected:

  - Coverage for a resource being callde
  - Coverage for rendering URLs

  These should be stored in a DBM database or a file, and then be collected for
  display.

  - Provide a tool to report coverage from the cmdline
  - Provide a resource to report coverage nicely in an HTML table

  You will need to set ctxt.resid in Resource.delegate() (you need this).

* Force initialization and raise an exception if the library is used without
  having been initialized properly.


* We need to provide a format string declaration for a component, e.g. for the
  ride-ids and event-ids, %08d

* Move the namexform outside of the mapper, and maybe as a global parameter that
  has to be set by glue code

  * Then you can add the resid from the delegate method, so that a resource and
    the template could render the resource id in the meta fields.

* Extent static checker script to look for parameters and to warn when it is
  likely that parameters have been forgotten or are missing or extraneous


(promotion)
* Send Ranvier information to twill list when the URL mapper for testing is
  complete.

* Save original Routes email for docs, it contains lots of info


(docs)
* In the docs, mention that the list of URLs can be used by a new developer to
  quickly get acquainted with the layout of a new project.  This could also be
  used to generate a site map.

* Mention that this could be used to generate the Google sitemap automatically.



Future
======

Multiple Components in a Row
----------------------------
s
* branch_var should accept a tuple of variable names, and the same should go for
  declare_serve(), so that we can express consuming more than a single path
  component:

     /doc/<year>/<month>/<date>
     /doc/<year>/<month>/<date>/view


Validate on Back-Mapping
------------------------

* It would provide even more robustness and verification if it was possible for
  the resources that consume components to provide some kind of validation for
  those components, so that when we back-map URLs for rendering more
  verification is performed that just “we have the parameter”.


Map Multiple URLs
-----------------

* Add a simple interface to be able to map “n” URLs (``mapurln(..)``) with the
  same arguments.


Features in Docs
----------------

* Implement all the remaining features described in the docs


Interfaces
----------

* Check out if WSGI dictates some kind of standard interface for implementing a
  response proxy.


Random Tests
------------

* We could use the introspection provided by url_variables() to generate
  fetchers with random data for urls that require arguments.


Query Parameters
----------------

* We also need to support query parameters for static mappings.

* Think about integrating the parameters with the query arguments at some point,
  so that we can generate URLs like this (maybe this could be done automatically
  by passing in extra arguments instead of raising an error):

     /a/bli/blou?myextra=42

* The enumerator visitor could be augmented with a method to accept declaration
  of possible query arguments, some being mandatory (this sounds like a cool
  idea).

  Also, a special function could be provided to do these declarations given an
  Atocha form, thus providing us with the complete interface to a speciific
  resource.  The pretty renderer could take advantage of that by rendering a
  nice table with those, and the fields' titles could even be declared as well,
  so that we can render a good interface of a resource.

* Add the following methods::

    declare_param( ..., optional=True ) -> adds a query arg

      ##     def declare_queryargs( self, varname, default=None, optional=False ):
      ##         """
      ##         Declare query arguments for this resource as a leaf.  Query arguments
      ##         can be optional, and can have default values only if they're not
      ##         optional.
      ##         """
      ##         assert not (optional and default)
      ## ## FIXME todo


    Only parameters can be optional.  Variables are required.

    Find a way to map the position parameters to the URL, in order.

Extra and Privileges
--------------------

- Add a optional parameter 'extra' which can be used to indicate, for
  informational purposes only, what extra data is involved/considered during
  the traversal for a particular leaf resource.  This can be used to display
  the privileges that are involved in accessing a single resource.


Template Replacement
--------------------

* We could provide a simple template replacement library in this package that
  replaces a simple syntax embedded in HTML::

      <a href="@@Profile(username=username, ...)">Search</a>

  This should be configured to use an appropriate mapper beforehand.  This
  should be trivial to implement.  Templates are a really stupid idea though--at
  least for a programmer--so this should be given low priority.


Redirection Oddity
------------------

* Investigate this: when you just return a Location: header without a status,
  Apache goes into an infinite loop.  What is this implementation of internal
  redirect?  Look for internal redirection on Wikipedia.


Formats for static routes
-------------------------

* Implement format support for static routes, we will need to detect the format
  from the given URL pattern, extending that syntax somehow.



