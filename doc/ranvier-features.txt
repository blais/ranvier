===============================================
   urlmaps: Mapping URLs in Web Applications
===============================================
:Author: Martin Blais <blais@furius.ca>
:Date: 2006-04-11
:Abstract:

   (Unfinished) Documentation on the Ranvier URL mapping system.


.. section-numbering::
.. contents::
..
    1   Introduction
    2   Problem Statement and Domains
    3   Mapping Forward
      3.1  Chain of Responsibility
      3.2  Naming of Resources
    4   Mapping Backward
      4.1  Optimization of BackMapping
      4.2  Selection of Resource Ids
      4.3  Static Maps
      4.4  Unique Identifiers
    5   Listing URLs
    6   Embedding Security
    7   Internal Redirects
    8   Support for Debugging
    9   A Routes-Like Interface
    10  (Other)


Introduction
============

Mapping URLs is an important component of building web applications.
…
(FIXME add more)



Problem Statement and Domains
=============================

Let's consider some of the important parts of a typical web application
framework:

1. Code that serves pages or performs a specific task when a URL is
   requested.  Let's call the documents served **resources** and the code that
   serves than **resource handlers**;

2. There is usually a way to **combine** the resource handlers to take advantage
   of common functionality.  For example, code that fetches a user's preferences
   may be needed in many places, and we would like to write the code once.  This
   could be as simple as allowing the definition of functions, or the
   elaboration of a complex hierarchical object-based system.  This could be
   done via aggregation/composition or inheritance, or using other paradigms;

3. **Pattern matching the URL** to select a particular resource handler to map it
   to;

4. **Capturing and validating** the variable components and the query arguments
   from the URL request string and provide them to the resource handler.  This
   is a task similar to **parsing**;

5. **Rendering other URLs back to the user**.  These are actually **delayed
   function calls**, which depend on the user's future actions.


.. figure:: domains.png

   The principal goal of this library is to convert between the domain of URLs
   and the domain of code objects (resource handlers).


You can view this problem as mapping back and forth between two domains: the
domain of URLs and the domain of source code.  As programmers, we should have
little concern for the particular URLs that our resources are accessed from, if
not for the correspondence between URL variable components and function
parameters, or for purely aesthetic reasons.  

All we need is some kind of system for uniquely identifying resources, and
rendering the appropriate URL given its parameters.  Most computer languages
provide some form or other of checking of parameter correctness when making
function calls.  Is it not silly then, that most web application
frameworks—especially those based on templates—still involve the programmer in
writing URLs when rendering pages?

The goals of this library are:

* To isolate the programmer's interface from the specifics URLs that the
  cross-referenced resources are bound to;

* To provide a system that better manages the list of resources that are
  available from a web application, that can list them, serve them for test
  programs, etc.

* To implement a simple but efficient forward mapping parsing mechanism based on
  aggregation of resources (the `chain-of-responsibility design pattern`__).

__ http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern


Mapping Forward
===============

We can view URLs are function calls into a running computer program, i.e::

   http://mysite.com/accounts/get_balance?user=blais&accno=643843

maps in a web application into a call to some function ``get_balance`` with two
parameters, *user* and *accno*::

  def get_balance( user, accno ):
      ...

This view is similar to the event loop model of desktop applications, where the
idle event loop consists of a server waiting for requests.  (The difference is
that the web's event loop serves multiple users and therefore must maintain
per-user global state, this is what we call *session data*, and it is
implemented using cookies, that a user's browser serves back to the server).

In the preceding example, the parameters were obvious, they were embedded in the
query arguments.  However, any part of the URL can be an argument::

  http://mysite.com/users/blais/acc/643843/get_balance/

This tends to produce nicer URLs and bends the user into conceptually organizing
the resources he makes available on his server in a hierarchy.  Query arguments
are best reserved for optional arguments.

Within this view, we can easily explain the concept of RESTfulness__: an
resource is said to comply to the principles of REST if it does not have
significant side-effects, i.e. if it does not rely on global state/variables as
input.

__ http://en.wikipedia.org/wiki/Representational_State_Transfer




One consequence of using our system is that we do not render *relative* URLs,
i.e. all the URLs are from the root.  This consists in an advantage:  FIXME add
more





Chain of Responsibility
-----------------------

(FIXME explain resource system and pattern matching algorithm)

One of the advantages in using a Chain of Responsibility pattern to implement
the controller search is that complete flexibility is available to the
programmer.  We have no need to define a complicated and necessarily limited
wildcard matching system.  The matching of URL components is entirely up to you,
i.e. you can look up information in a database, augment the context object that
is passed along the search, etc.  This is much more powerful (and simpler) than
a wildcard system.



Naming of Resources
-------------------

The overwhelmingly general case for leaf resources/controllers is that they are
instantiated only once.  We thus take the opportunity to forego having the user
enter resource names for each of these.  Instead, we reuse the names of the
classes of the leaf controllers to enter them in the URL map.

For those few cases where controllers are reused and instantiated in many
places, we provide an optional keyword argument to let the user uniquely name
the instances for later referral.



Mapping Backward
================

One problem with web applications is that due to the nature of the web
application frameworks, they tend to be rather static and difficult to change.
URLs are cross-referenced from page templates and sometimes build
programmatically, and it can be tricky to move resources around.

A solution for this is to let the URL construction be taken care of by the
resource system itself, mapping from the leaf of the URL back to the root, thus
re-constructing the original resource.

We can identify individual resources by using unique strings (e.g. ``//balance``
the user account balance page) and then asking a central URL mapping service to
create the URLs for us to insert in web pages.  This process must require all
the parameters of the function to call, in order to insert them in their
appropriate place.

A web application build this way can be completely rearranged without breaking.


However, this flexibility makes using templates impossible.


Optimization of BackMapping
---------------------------

- Ask each resource whether it is

  * Static
  * A fixed name (e.g. user)
  * Programmatic (cannot optimize)

FIXME todo write docs








Selection of Resource Ids
-------------------------

You should choose some kind of common string pattern for you resource ids, so
that if you decide to rename some of them at some point, for example when
reorganizing a site, simple text-based UNIX tools can do a wonderful job at
automating some of these replacments if they can be picked out easily.

The default naming transform 

  … describe ``@@<ResourceName>`` scheme






Static Maps
-----------

Since we already have a global registry of URL maps that we use to generate our
URLs, we also provide the ability to map names to static and possibly external
URLs.  This is similar to Routes’ “static named routes” feature.





Unique Identifiers
------------------

FIXME do this, talk about the automatic conversion from the class names and the
possibility to identify instances.

  * We need to automatically compute these names from the names of the
    classes, and a class attribute can be used on the classes to override that
    as well as it should be able to be specified as a keyword argument on the
    base class.





Listing URLs
============

One nice feature of our system is that we like to be able to get an entire list
of the URLs served by the system.  This is extremely useful, because:

#. We visually appreciate the entire list of documents which are offered to the
   public.  We need this, because during development it is possible that
   temporary resources are installed for debugging and later on forgotten.

#. Our test programs can automatically fetch this list (from a special resource
   only served in testing mode) and can rebuild a mapper from it, so that they
   are entirely independent of the application URL layout.

(#. Can inspect the various security credentials that each URL requires.)


Embedding Security
==================

The URLs can be grouped so that they share security access privileges.  For
example, any URL beginning with ``/backstore`` could require administrative
privileges.

One way to do this





Internal Redirects
==================

FIXME write it



Support for Debugging
=====================

FIXME write it


A Routes-Like Interface
=======================

FIXME answer what is “Routes”


* provide an interface that is similar to routes, but that automatically creates
  all the required resources underneath











(Other)
=======

Idea: in our resources traversal, we could put the query args together with the
parameters in the URL itself… they are really conceptually the same…



